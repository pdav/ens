%
% Historique
%   2014/08/30 : pda : conception
%

\def\inc{inc2-api}

\titreA {Processus et threads : les API}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titreB {Introduction}

\begin {frame} {Introduction}
    Problème de la concurrence = partage de mémoire \\
    \implique comment partager la mémoire dans un programme ?

    \vfill

    Introduction aux API\footnote {Application Programming Interface}
    Unix et POSIX

    \begin {itemize}
	\item pour le partage de mémoire entre processus
	\item pour les threads
    \end {itemize}
\end {frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rappels sur les processus
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titreB {Rappels sur les processus}

\begin {frame} {Rappels -- Processus}
    Qu'est-ce qu'un processus ?

    \vfill

    Définition 1 (haut niveau)~:
    \begin {quote}
	Un processus est une instance d'un programme
	en cours d'exécution

    \end {quote}

    \vfill

    Exemples~:
    \begin {itemize}
	\item je tape «~\texttt {ls /tmp}~» : le programme \texttt {ls}
	    est exécuté avec la donnée \texttt {/tmp}
	    (et donc implicitement le contenu de \texttt {/tmp} car on
	    sait ce que fait \texttt {ls})

	\item je relance la même commande : ce n'est pas le même
	    processus (c'est une autre exécution avec le même jeu de
	    données)

    \end {itemize}
\end {frame}


\begin {frame} {Rappels -- Processus}
    De plus, un processus possède des attributs~:

    \begin {itemize}
	\item état
	\item identité (PID)
	\item propriétaire (UID)
	\item répertoire courant (CWD)
	\item terminal de contrôle
	\item ouvertures de fichiers
	\item actions définies pour les signaux
	\item etc.
    \end {itemize}

\end {frame}

\begin {frame} {Rappels -- Processus}
    Primitives POSIX de gestion des processus~:

    \begin {itemize}
	\item \code {pid\_t fork (void)}

	    Création d'un nouveau processus par duplication du 
	    processus courant

	\item \code {void exit (int val)}

	    Terminaison du processus courant

	\item \code {pid\_t wait (int *pval)} (et autres \texttt {wait}*)

	    Attente de la terminaison d'un des processus fils

    \end {itemize}

    Les primitives \texttt {exec}* ne servent pas plus à la gestion des
    processus que \texttt {chdir}, \texttt {kill} ou \texttt {sigaction}.

\end {frame}

\begin {frame} {Rappels}

    Exemple de diagramme d'états de processus

    \begin {center}
	\includegraphics [width=.9\linewidth] {\inc/ps-state}
    \end {center}

    Ressources~: E/S, date, événement d'un autre processus, etc.

\end {frame}

\begin {frame} {Rappels -- Processus}
    Qu'est-ce qu'un processus ?

    \vfill

    Définition 2 (bas niveau)~:
    \begin {quote}
	Un processus est matérialisé par ses attributs, un contexte
	CPU et un espace mémoire

    \end {quote}

    \vfill

    Contexte CPU :
    \begin {itemize}
	\item registres du processeur
	    \begin {itemize}
		\item registres généraux (ex: EAX, EBX, etc. sur x86)
		\item registre PC (\textit {Program Counter}, EIP sur x86)
		\item registre SP (\textit {Stack Pointer}, ESP sur x86)
		\item registre SR (\textit {Status Register}, EFLAGS sur x86)
		\item registres spécialisés (ex: registres MMX sur x86)
	    \end {itemize}
	\item ce contexte est sauvegardé en mémoire lorsque le processus
	    n'est pas sur le processeur
    \end {itemize}

\end {frame}

\begin {frame} {Rappels -- Processus}
    \begin {center}
	\includegraphics [width=\linewidth] {\inc/ps-def}
    \end {center}
\end {frame}

\begin {frame} {Rappels -- Interruptions et exceptions}
    Entrée dans le noyau~:
    \begin {itemize}
	\item interruption (ex: fin d'E/S, etc.)
	    \\
	    \implique événement provoqué par un mécanisme externe
	    (contrôleur d'E/S, horloge, etc.)
	\item exception (ex: violation d'adresse, division par 0, etc.)
	    \\
	    \implique événement provoqué (volontairement ou non)
		par le programme

	\item appel système 
	    \implique exception provoquée par
		une instruction spécifique (ex: INT sur x86, TRAP
		sur 68000)
    \end {itemize}

    \vfill

    Les traitements sont très proches
\end {frame}

\begin {frame} {Rappels -- Interruptions et exceptions}
    Actions du processeur suite à une exception~:
    \begin {enumerate}
	\item lorsque l'exception se produit, PC pointe dans le code du
	    processus, SP dans la pile du processus et SR indique qu'on
	    est en mode «~utilisateur~» (par exemple)
	    \\
	    {\footnotesize En cas d'interruption, le processeur bloque
	    (masque) en plus les interruptions en modifiant le masque
	    d'interruptions dans SR}

	\item le processeur sauvegarde ces registres dans la pile
	    d'exécution noyau associée au processus

	    {\footnotesize Note~: la pile d'exécution du noyau est
	    retrouvée par un mécanisme dépendant du processeur
	    (registre spécifique pour Motorola 68000, indirection
	    via lecture du TSS pour x86)}

	\item le processeur initialise PC à partir du vecteur
	    d'interruption, SP à partir de l'adresse de la pile noyau,
	    et SR pour indiquer le mode «~système~»

    \end {enumerate}
    \implique tout ceci est effectué par le matériel
\end {frame}

\begin {frame} {Rappels -- Interruptions et exceptions}
    \begin {center}
	\includegraphics [width=\linewidth] {\inc/ps-except}
    \end {center}
\end {frame}

\begin {frame} {Rappels -- Interruptions et exceptions}
    Une fois le contexte (PC, SP, SR) initialisé, le processeur exécute
    le code du système d'exploitation~:

    \begin {enumerate}
	\item (en assembleur) sauvegarde du reste du contexte CPU
	    (registres généraux, etc.)

	\item (en assembleur) mise en place d'un contexte de pile
	    pour un appel de procédure en langage de haut niveau (ex: C)

	\item (en assembleur) branchement à une adresse

	\item (en C) vérification de la raison de l'exception

	\item (en C) action correspondant à l'exception

    \end {enumerate}
\end {frame}

\begin {frame} {Rappels -- Interruptions et exceptions}
    Au retour~:

    \begin {itemize}
	\item actions logicielles symétriques en fin d'exception (en
	    C puis en assembleur)

	\item actions (en matériel) symétriques à la prise en compte
	    de l'exception : instruction spéciale (IRET pour x86,
	    RTE pour 68000)

    \end {itemize}
\end {frame}

\begin {frame} {Rappels -- Commutation de processus}

    La commutation de processus survient~:
    \begin {itemize}
	\item suite à l'interruption de l'horloge entraînant le recalcul
	    des priorités des processus

	\item suite à l'abandon du processeur par un processus via
	    un appel de primitive système (i.e. une exception) \\
	    \implique demande d'E/S, attente d'un signal, etc.
    \end {itemize}

    \vspace* {3mm}
\end {frame}

\begin {frame} {Rappels -- Commutation de processus}

    Techniquement, la commutation de processus (P$_1 \rightarrow$ P$_2$) est~:
    \begin {itemize}
	\item le changement de la variable du noyau indiquant
	    le processus courant \\
	    (variable multiple pour les multi-processeurs)

	\item la restauration des registres du processus remis
	    sur le processeur \\
	    \implique fin du traitement de l'interruption ayant
	    entraîné la suspension de P$_2$

    \end {itemize}

\end {frame}

\begin {frame} {Rappels -- Commutation de processus}

    \begin {center}
	\includegraphics [width=.85\linewidth] {\inc/ps-commut}
    \end {center}

\end {frame}


\begin {frame} {Rappels -- Adressage logique}

    Espace d'adressage logique d'un processus

    \vspace* {2mm}

    \begin {minipage} {.55\linewidth}
	Chaque processus dispose~:
	\begin {itemize}
	    \item du segment «~\emph {text}~» \\
		(non modifiable)
	    \item du segment «~\emph {data}~» \\
		(extensible via \texttt {malloc})
	    \item du segment «~\emph {stack}~» \\
		(extensible automatiquement)
	    \item et éventuellement d'autres
		segments (bibliothèques dynamiques...)
	\end {itemize}

    \end {minipage}
    \hfill
    \begin {minipage} {.43\linewidth}
	\begin {center}
	\includegraphics [width=.7\linewidth] {\inc/ps-mem}
	\end {center}
    \end {minipage}
\end {frame}

\begin {frame} {Rappels -- Adressage physique}
    Chaque processus a son propre espace d'adressage~:

    \begin {minipage} {.58\linewidth}

	Les programmes utilisent des adresses \textit {relatives} à
	l'espace d'adressage du processus.

	\vspace* {3mm}

	Exemple~: un programme utilise la case mémoire d'adresse
	1000. Si deux processus exécutent ce programme, chacun doit
	avoir sa propre case d'adresse 1000. Ces deux cases ont
	une adresse réelle différente en mémoire.

    \end {minipage}
    \hfill
    \begin {minipage} {.40\linewidth}
	\begin {center}
	    \includegraphics [width=.9\linewidth] {\inc/trans-adr}
	\end {center}
    \end {minipage}
\end {frame}

\begin {frame} {Rappels -- Traduction d'adresses}

    Unité de gestion mémoire (MMU)~:
    \begin {center}
	\includegraphics [width=.7\linewidth] {\inc/mmu-princ}
    \end {center}

    \begin {itemize}
	\item CPU présente une adresse logique sur le bus d'adresses
	\item si adresse $\geq$ limite, alors exception
	\item si adresse < limite, alors MMU calcule l'adresse physique \\
	    (adresse physique = adresse logique + limite)
    \end {itemize}
\end {frame}

\begin {frame} {Rappels -- Traduction d'adresses}
    Cette MMU est irréaliste~: trop simple pour les cas réels

    \begin {itemize}
	\item pas de prise en compte de l'adresse 0
	\item les processus ont des «~trous~» dans leur espace
	    d'adressage \\
	    (ex~: espace entre segment «~data~» et «~stack~»)
	\item les segments d'un processus ne sont pas forcément contigüs
	    en mémoire physique
	\item pas de possibilité de partager un segment \\
	    (ex~: partage du segment «~text~» entre processus)
    \end {itemize}

    \implique mais elle est pédagogique !

\end {frame}

\begin {frame} {Rappels -- Traduction d'adresses}

    Retour sur la commutation de processus

    \vspace* {1mm}

    Avec notre MMU simpliste, il suffit~:

    \vspace* {1mm}

    \begin {minipage} {.45\linewidth}

	\begin {itemize}
	    \item de considérer qu'il n'y a pas de traduction
		d'adresse lorsque le CPU est en mode «~système~»

	    \item d'intégrer les deux registres «~limite~» et «~base~»
		lors de la sauvegarde et de la restauration des
		registres

	    \item vider le cache

	\end {itemize}

    \end {minipage}
    \hfill
    \begin {minipage} {.53\linewidth}
	\includegraphics [width=\linewidth] {\inc/ps-commut}
	\\
	\centerline {\tiny (Même dessin que précédemment)}
    \end {minipage}
\end {frame}

\begin {frame} {Rappels -- Traduction d'adresses}

    Unité de gestion mémoire du HP 9000-IPC~:

    \begin {center}
	\includegraphics [width=.5\linewidth] {\inc/mmu-ipc}
    \end {center}

    \begin {itemize}
	\item MMU «~câblée~»
	\item type d'accès mémoire (U/S, D/P) \implique registre consulté
	\item additionneur seul \implique pas de vérification de limite \\
	    (machine mono-utilisateur)
    \end {itemize}

\end {frame}

\begin {frame} {Rappels -- Traduction d'adresses}

    Principe de l'unité de gestion mémoire du PDP 11/45~:

    \begin {center}
	\includegraphics [width=.55\linewidth] {\inc/mmu-pdp11a}
    \end {center}

    \begin {itemize}
	\item espace d'adressage d'un processus découpé en 8 segments
	\item mémoire physique découpée en blocs de $2^6$ octets
	\item chaque segment est traduit par un registre de la MMU

    \end {itemize}

\end {frame}

\begin {frame} {Rappels -- Traduction d'adresses}

    Traduction d'adresse sur le PDP 11/45~:

    \begin {center}
	\includegraphics [width=.45\linewidth] {\inc/mmu-pdp11b}
    \end {center}

    \begin {itemize}
	\item mémoire physique découpée en blocs de $2^6$ octets
	\item limite d'un segment : sur 7 bits
	\item jusqu'à 8 segments entre 1 et 2$^7$ blocs (64 à
	    8192 octets)

    \end {itemize}

\end {frame}

\begin {frame} {Rappels -- Mémoire virtuelle}
    Jusqu'ici, traduction mémoire «~simple~»

    \begin {itemize}
	\item mémoire d'un processus : divisée en
	    $p$ blocs de $2^k$ octets

	    Sur PDP 11/45~: $p=2^3 = 8$, $k=13$ \implique $2^k = 8192$ octets

	\item adapté pour les 3 segments d'un processus \\
	    et peut-être d'autres segments supplémentaires
	    (bibliothèques dynamiques, mémoire partagée, etc.)

	\item pour que le processus soit mis sur le processeur,
	    il faut que tout son espace d'adressage soit en mémoire
    \end {itemize}

\end {frame}

\begin {frame} {Rappels -- Mémoire virtuelle}

    Besoins nouveaux~:
    \begin {itemize}
	\item exécuter des programmes de taille supérieure à la
	    mémoire physique

	\item rationnaliser l'utilisation de la mémoire \\
	    un processus n'a pas besoin de tout son espace d'adressage
	    pendant toute sa durée de vie

	    Exemple : code d'initialisation parcouru une seule
	    fois
    \end {itemize}

    \vspace* {3mm}

    \implique Mémoire virtuelle (pagination)

\end {frame}

\begin {frame} {Rappels -- Mémoire virtuelle}

    Principes~:

    \begin {itemize}
	\item l'espace mémoire est découpé en pages de taille $2^n$ \\
	    Ex~: $n = 12$ \implique $2^n = 4096$ octets (cas le plus courant) \\
	    Ex~: $n = 22$ \implique $2^n = 4$ Mo (\emph {superpages}
		sur x86)

	\item chaque page peut être chargée en mémoire ou non

	\item la MMU gère une «~table des pages~» par processus

	\item «~défaut de page~» : la MMU génère une exception \\
	    \implique le noyau traite l'exception
	
	\item lorsque le noyau aura chargé la page en mémoire et
	    positionné la table des pages, le processeur pourra à
	    nouveau tenter l'exécution de l'instruction «~fautive~»
	    \\
	    \implique les instructions sont «~redémarrables~»

    \end {itemize}

\end {frame}

\begin {frame} {Rappels -- Mémoire virtuelle}

    Unité de gestion mémoire du i386~:

    \begin {center}
	\includegraphics [width=\linewidth] {\inc/mmu-i386}
    \end {center}
\end {frame}

\begin {frame} {Rappels -- Mémoire virtuelle}

    Exemple du i386~:

    \begin {itemize}
	\item segmentation : poids du passé, on oublie...
	\item adresse après segmentation sur 32 bits
	\item la table «~page directory~» est~:
	    \begin {itemize}
		\item référencée par le registre CR3 du processeur
		\item indexée par les 12 bits de poids fort de l'adresse
	    \end {itemize}
	\item chaque table des pages est~:
	    \begin {itemize}
		\item référencée par l'entrée dans «~page directory~»
		\item indexée par les 12 bits de poids milieu de l'adresse
	    \end {itemize}
	\item l'adresse physique est constituée~:
	    \begin {itemize}
		\item de l'adresse de la page trouvée dans la table des page
		\item de l'offset dans la page récupéré de l'adresse originale
	    \end {itemize}

    \end {itemize}

\end {frame}

\begin {frame} {Rappels -- Mémoire virtuelle}
    Les tables des pages résident en mémoire~:

    \begin {itemize}
	\item commutation de processus \implique changer l'adresse de la
	    table des pages
	    \\
	    (registre CR3 sur x86)

	\item les tables de pages peuvent être swappées sur le disque

	\item la traduction d'une adresse peut elle-même conduire
	    à un défaut de page

	\item traduction lente, même sans défaut de page \\
    \end {itemize}

    Optimisation des traductions~:
    \begin {itemize}
	\item TLB (\emph {Translation Lookaside Buffer\/}) \\
	    \implique cache des dernières traductions d'adresse \\

    \end {itemize}

\end {frame}

\begin {frame} {Rappels -- Mémoire virtuelle}

    Exemple pour Pentium III (x86)~: TLB «~\emph {4-way set-associative}~»

    \begin {center}
	\includegraphics [width=.9\linewidth] {\inc/mmu-tlb386}
    \end {center}

    {\footnotesize Ne pas oublier de vider le TLB lors de la commutation
    de processus...}
\end {frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Partage de mémoire entre processus
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titreB {Partage de mémoire entre processus}

\begin {frame} {Partage de mémoire en processus}
    Objectif de la gestion mémoire dans un système : assurer
    l'étanchéïté des espaces mémoires entre processus \\
    (\implique objectif de sécurité du système)

    \vfill

    Besoin de performances en multi-processeurs \\
    \implique besoin de partager des portions de mémoire \\
    \implique développement d'interfaces de programmation idoines
\end {frame}


\begin {frame} {Partage de mémoire en processus}
    API disponibles :

    \begin {itemize}
	\item IPC System V (\code {shmget}/\code {shmat}/etc)

	    \implique origine AT\&T, vieille interface, orthogonale avec
		le reste du système, très répandue

	\item \code {mmap}/\code {munmap}

	    \implique origine Berkeley, partage de mémoire = effet de
		bord de la projection d'un fichier en mémoire, simple,
		peu répandue

	\item \code {shm\_open}/\code {shm\_unlink}

	    \implique origine POSIX, simple et élégant, encore peu
		répandue

    \end {itemize}

    \vspace* {3mm}

    Dans ce cours~: IPC System V

\end {frame}

\begin {frame} {IPC System V}

    Les IPC System V fournissent~:

    \begin {itemize}
	\item des files de messages

	    \implique dans ce cours : exemple d'utilisation des IPC
	    System V

	\item des segments de mémoire partagée

	    \implique l'objet principal de ce cours

	\item des groupes de sémaphores

	    \implique cours ultérieur

    \end {itemize}

\end {frame}

\begin {frame} {IPC System V}
    Les «~objets~» IPC System V~:
    \begin {itemize}
	\item ont la durée de vie du système

	    Ils sont conservés dans la mémoire du noyau \\
	    \implique effacés lorsque le noyau s'arrête ou lors d'une
		suppression explicite

	\item sont désignés par une \textit {clef} (type \code {key\_t})

	    Sorte de nom = convention entre tous les programmes participant
	    à la communication

	\item sont identifiés par un \textit {identificateur} (type
	    \code {int})

	    Un identificateur identifie un objet \textit {existant}

	\item sont créés (ou accédés s'ils existent) via les primitives~:

	    \begin {itemize}
		\item \code {int id = msgget (clef, ...)}
		\item \code {int id = shmget (clef, ...)}
		\item \code {int id = semget (clef, ...)}
	    \end {itemize}

    \end {itemize}

    \vspace* {3mm}

\end {frame}

\begin {frame} {IPC System V}
    Analogie avec les fichiers~:

    \begin {center}
	\small
	\begin {tabular} {|l|c|c|} \cline {2-3}
	    \multicolumn {1} {c|} {~}
		& \textbf {IPC System V} & \textbf {Fichier} \\ \hline
	    \textbf {Nom}
		& clef & nom de fichier \\
	    	& (\code {key\_t}) & (\code {char *}) \\ \hline
	    \textbf {Durée de vie}
		& arrêt du & suppression \\
		& système ou & du fichier \\
		& suppression & \\
		& explicite & \\ \hline
	    \textbf {Accès/création}
		& primitives & primitive \\
		& \code {xxxget()} & \code {open()} \\ \hline
	    \textbf {Descripteur}
		& id (\code {int}) & descripteur \\
		& & de fichier (\code {int}) \\ \hline
	\end {tabular}
    \end {center}
\end {frame}

\begin {frame} {IPC System V}
    Comment choisir une clef ? \\
    \implique convention entre les participants à la
    communication

    \begin {itemize}
	\item choisir un nombre au hasard ? \\
	    \implique possibilité de collisions

	\item faire appel à un annuaire de clefs ? \\
	    \implique bonne idée, mais ça n'existe pas...
    \end {itemize}

    Solution (\textit {hack})~: fonction de bibliothèque \code {ftok}

\end {frame}

\begin {frame} {IPC System V}
    \code {key\_t ftok (char *fichier, int projet)}

    \vspace* {3mm}

    Élaboration de la clef, par exemple à partir de :
    \begin {center}
    \begin {tabular} {|r|l|} \hline
	16 bits & numéro d'inode du fichier \\ \hline
	8 bits & numéro de périphérique (mineur) du fichier \\ \hline
	8 bits & \texttt {projet} \\ \hline
    \end {tabular}
    \end {center}

    \vspace* {3mm}

    \begin {itemize}
	\item avec de la chance, cette clef est unique
	    \\
	    (personne ne l'utilise déjà)
	\item si tout le monde utilise \code {ftok} avec des valeurs
	    différentes, il y a des chances que cette clef soit et reste unique
    \end {itemize}


\end {frame}

\begin {frame} {IPC System V}
    Cas spécial de clef~: \code {IPC\_PRIVATE}

    \begin {itemize}
	\item primitives \code {xxxget} créent un objet «~anonyme~»
	    \\
	    (aucune clef ne correspond à un tel objet)

	\item l'objet dispose d'un identificateur \\
	    (retourné par les primitives \code {xxxget})

	\item l'objet est partagé par le créateur et ses descendants \\
	    (cf descripteurs de tube anonyme)

	\item attention toutefois : l'objet n'est pas implicitement
	    détruit \\
	    (suppression explicite nécessaire)

    \end {itemize}

    \implique intéressant pour une communication entre processus
    apparentés (i.e. avec un ancêtre commun)

\end {frame}

\begin {frame} {Files de messages}
    Exemple d'utilisation~: les files de messages

    \begin {center}
	\includegraphics [width=.9\linewidth] {\inc/msg}
    \end {center}

    Une file de message possède des attributs~:
    \begin {itemize}
	\item permissions : lecture/écriture, utilisateur/groupe/autres
	\item dates de dernière opération : envoi, réception
	\item taille : nombre de messages, nombre d'octets
	\item etc.
    \end {itemize}

\end {frame}

\begin {frame} {Files de messages}
    \begin {center}
	\includegraphics [width=.6\linewidth] {\inc/msg}
    \end {center}

    Chaque message individuel~:

    \begin {itemize}
	\item comprend en premier un \texttt {long int} (toujours $> 0$)\\
	    \implique permet au récepteur de sélectionner
	    les messages
	\item le format du reste du message est à la charge de l'application
	\item lorsqu'on donne une taille de message, celle-ci est
	    \emph {sans} le \texttt {long int} (cf \code {msgsnd}
	    et \code {msgrcv})
    \end {itemize}

\end {frame}

\begin {frame} [fragile] {Files de messages}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=13, lastline=27] {\inc/ipc-msg.c}
\end{frame}

\begin {frame} [fragile] {Files de messages}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=29, lastline=43] {\inc/ipc-msg.c}
\end{frame}

\begin {frame} [fragile] {Files de messages}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=45, lastline=52] {\inc/ipc-msg.c}
\end{frame}

\begin {frame} [fragile] {Files de messages}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=54, lastline=69] {\inc/ipc-msg.c}
\end{frame}

\begin {frame} [fragile] {Files de messages}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=71, lastline=79] {\inc/ipc-msg.c}
\end{frame}


\begin {frame} {Files de messages}
    Le type du message (toujours > 0) est utilisé comme critère
    d'extraction d'un message de la file (avec \code {msgrcv})

    \vspace* {3mm}

    Selon la valeur du paramètre \code {type} de \code {msgrcv}~:
    \begin {itemize}
	\item si \code {type} = 0 : le premier message en attente est
	    lu, quel que soit son type
	\item si \code {type} > 0 : le premier message en attente du
	    type demandé est lu
	\item si \code {type} < 0 : le premier message en attente dont
	    le type est inférieur ou égal à -\code {type} est lu
	    \\
	    exemple~: si \code {type} = -25, lecture du premier message
	    dont le type $\in [1..25]$
    \end {itemize}

\end{frame}


\begin {frame} {Mémoire partagée}

    Primitives d'accès à la mémoire partagée~:

    \begin {itemize}
	\item \code {shmget}~: crée ou accède à un objet de type
	    «~segment de mémoire partagée~»
	\item \code {shmctl}~: opérations (p. ex. suppression) sur
	    un segment

	    \vspace* {3mm}

	\item \code {shmat}~: attache un segment existant dans l'espace
	    d'adressage du processus courant

	\item \code {shmdt}~: retire (détache) le segment de l'espace
	    d'adressage
    \end {itemize}
\end {frame}

\begin {frame} {Mémoire partagée}

    Attachement d'un segment de mémoire~:

    \begin {center}
	\includegraphics [width=.6\linewidth] {\inc/shmat}
    \end {center}

    Attention~: le segment de mémoire n'est pas forcément attaché à
    la même adresse virtuelle dans les différents processus !

\end {frame}

\begin {frame} [fragile] {Mémoire partagée}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=13, lastline=27] {\inc/ipc-shm.c}
\end{frame}

\begin {frame} [fragile] {Mémoire partagée}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=29, lastline=43] {\inc/ipc-shm.c}
\end{frame}

\begin {frame} [fragile] {Mémoire partagée}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=45, lastline=52] {\inc/ipc-shm.c}
\end{frame}

\begin {frame} [fragile] {Mémoire partagée}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=54, lastline=67] {\inc/ipc-shm.c}
\end{frame}

\begin {frame} [fragile] {Mémoire partagée}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=69, lastline=82] {\inc/ipc-shm.c}
\end{frame}

\begin {frame} {Mémoire partagée}

    Attention~: le segment de mémoire n'étant pas forcément attaché
    à la même adresse virtuelle dans les différents processus, ne
    jamais mettre de pointeur dans les segments de mémoire partagée.

\end {frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Les threads
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titreB {Définition des threads}

\begin {frame} {Threads}

    Les processus ne sont pas adaptés au parallélisme à grain fin

    \begin {itemize}
	\item commutation de processus lente \\
	    \implique sauvegarde et restauration du contexte,
		sélection du processus, \emph {changement d'espace
		d'adressage} et \emph {invalidation du TLB}

	\item communication inter-processus (tubes, messages) lente \\
	    \implique création de la mémoire partagée

	\item manque d'outils de synchronisation

    \end {itemize}
\end {frame}

\begin {frame} {Threads}
    Début des années 1980~: apparition des \emph {threads} (ou \emph
    {processus légers})

    \begin {itemize}
	\item plusieurs fils d'exécution
	\item un seul espace mémoire
    \end {itemize}

    \vspace* {3mm}

    Idée~: alléger la commutation de processus \\
    \implique faire le maximum de choses en mode utilisateur

    \begin {itemize}
	\item éliminer la commutation d'espace mémoire \\
	    (sauvegardes/restaurations du contexte MMU)
	\item permettre l'ordonnancement en mode utilisateur
	\item accès direct au support matériel pour la
	    synchronisation
    \end {itemize}

\end {frame}

\begin {frame} {Threads}
    Les threads d'un processus partagent~:
    \begin {itemize}
	\item l'identificateur du processus et son propriétaire
	\item l'\emph {espace mémoire unique} du processus
	\item les fichiers ouverts
	\item les actions associées aux signaux
	\item etc.
    \end {itemize}

    Chaque thread dispose~:
    \begin {itemize}
	\item de son identificateur de thread
	\item de son propre fil d'exécution \\
	    \implique sauvegarde et restauration du contexte CPU \\
	    (sans le contexte MMU)
	\item de sa propre pile d'exécution
    \end {itemize}

\end {frame}

\begin {frame} {Threads}
    \begin {center}
	\includegraphics [width=.6\linewidth] {\inc/thr-intro}
    \end {center}

    \begin {itemize}
	\item chaque processus a son propre espace d'adressage et un fil
	    d'activité
	\item les différents threads sont autant de fils d'activité
	    se partageant un même espace d'adressage
    \end {itemize}
\end {frame}

\begin {frame} {Threads}
    Espace d'adressage du processus~:
    \begin {minipage} {.65\linewidth}
	\begin {itemize}
	     \item zone «~data~» : variables globales

		\implique partagées par les threads

	     \item zone «~stack~» : chaque thread a sa
		propre pile d'exécution

		Attention : taille de la pile bornée \\
		\implique pas d'accroissement possible \\
		\implique taille fixée à la création \\
		\implique pas de détection de saturation !
	\end {itemize}
    \end {minipage}
    \hfill
    \begin {minipage} {.33\linewidth}
	\includegraphics [width=\linewidth] {\inc/thr-stack}
    \end {minipage}

\end {frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API des THREADS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titreB {API de gestion des threads}

\begin {frame} {Threads}
    API normalisée par POSIX

    \begin {itemize}
	\item fichier d'inclusion : \code {\#include <pthread.h>}
	\item édition de liens : \texttt {cc -o ...-l pthread}
    \end {itemize}

    Types~:

    \begin {itemize}
	\item \code {pthread\_t}~: identificateur de thread
	\item \code {pthread\_attr\_t}~: attribut de thread
    \end {itemize}
\end {frame}

\begin {frame} {Threads}
    Fonctions de l'API~:

    \begin {itemize}
	\item création de thread~:

	    \code {int pthread\_create (pthread\_t *id, const
		pthread\_attr\_t *attr, void *(*fonction)(void *), void *arg)}

	\item fin de thread~:

	    \code {int pthread\_exit (void *valretour)}

	\item attente de fin de thread~:

	    \code {int pthread\_join (pthread\_t id, void **valretour)}

    \end {itemize}

\end {frame}

\begin {frame} {Threads}
    Illustration~: 4 threads (principal + 3 nouveaux)
    \begin {center}
	\includegraphics [width=.9\linewidth] {\inc/thr-api}
    \end {center}
\end {frame}

\begin {frame} [fragile] {Threads}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=5, lastline=19] {\inc/thr.c}
\end{frame}

\begin {frame} [fragile] {Threads}
    \lstinputlisting [basicstyle=\scriptsize\lstmonstyle, firstline=27, lastline=50] {\inc/thr.c}
\end{frame}

\begin {frame} {Fonctions «~thread-safe~»}
    La plupart des fonctions de bibliothèque ont été créées avant
    l'apparition des threads

    \begin {itemize}
	\item La plupart n'ont pas nécessité de modifications

	    Exemples~: \code {strlen}, \code {isalpha}, etc.

	\item Pour certaines, l'implémentation a dû être modifiée

	    \implique ajout de synchronisations
	    (cf cours suivant)

	\item Quelques unes \textbf {ne peuvent pas} être compatibles
	    avec les threads :

	    \begin {itemize}
		\item stockage d'un état dans une variable unique
		\item retour d'une adresse pointant dans une variable unique
	    \end {itemize}

	    \implique Problème de conception des fonctions

    \end {itemize}

\end {frame}

\begin {frame} [fragile] {Fonctions «~thread-safe~» -- État global}
    
    Stockage d'un état dans une variable unique~:

    \begin {itemize}
	\item Exemple (découpage d'une chaîne en tokens)~:

\begin {lstlisting}
char *strtok (char *str, char *delim) {
  static char *last ;
  /* variable last unique pour tous les threads */
  ...
}
\end{lstlisting}

	\item L'état actuel du parcours dans \code {str} est mémorisé
	    dans \code {last}

	    \begin {itemize}
		\item Si deux threads utilisent \code {strtok} sur
		    des chaînes différentes, la variable \code {last}
		    renvoie à l'un des threads un pointeur dans la
		    chaîne de l'autre thread

	    \end {itemize}


	\item Problème inhérent à la définition de \code {strtok}

    \end {itemize}
\end{frame}

\begin {frame} {Fonctions «~thread-safe~» -- État global}

    \begin {itemize}
	\item Définition d'une nouvelle fonction

	\item \code {\small char *strtok\_r (char *s, char *delim, char **parcours)}

	\item La variable \code {last} est «~sortie~» de
	    \code {strtok} via \code {parcours}

    \end {itemize}

\end {frame}

%\begin {frame} {Threads}
%    \begin {itemize}
%	\item ex: \code {int rand (void)}
%
%	    Génère un nombre pseudo-aléatoire $u_{n+1} = f(u_n)$
%
%	    L'état $u_n$ est stocké dans une variable globale
%
%	    \begin {itemize}
%		\item 2 threads différents peuvent calculer la même
%		    valeur $u_{n+1}$
%		\item risque de corrompre l'état global $u_n$
%	    \end {itemize}
%
%    \end {itemize}
%\end {frame}


\begin {frame} [fragile] {Fonctions «~thread-safe~» -- Retour global}

    Retour d'adresse pointant dans une variable unique :

    \begin {itemize}

	\item Exemple (lecture de répertoire)~:
\begin {lstlisting}
struct dirent *readdir (DIR *dirp) {
  /* variable d unique pour tous les threads */
  static struct dirent d ;
  ...
  return &d ;
}
\end{lstlisting}

	    \begin {itemize}
		\item Si deux threads utilisent \code {readdir}, la
		    lecture par le deuxième thread remplace la donnée
		    que le premier thread n'a peut être pas encore
		    exploitée

		\item \code {readdir} ne peut pas faire autrement~:
		    la spécification des fonctions \code {xxxdir}
		    ne permet pas d'allouer ou de libérer la mémoire
		    utilisée par \code {readdir}

	    \end {itemize}

	\item Problème inhérent à la définition de \code {readdir}

    \end {itemize}
\end{frame}

\begin {frame} {Fonctions «~thread-safe~» -- Retour global}

    \begin {itemize}
	\item Définition d'une nouvelle fonction

	\item \code {\small int readdir\_r (DIR *dirp, struct dirent
	    *entry, struct dirent **result)}

	\item Le résultat est placé dans une zone de mémoire allouée
	    par l'appelant \\
	    \implique adresse précisée par \code {entry} \\
	    \implique adresse de \code {entry} placée dans \code
	    {result}

	\item En fin de répertoire, \code {NULL} est placé dans
	    \code {result}

    \end {itemize}

\end {frame}

\begin {frame} {Fonctions «~thread-safe~»}
    Attention donc aux fonctions qui ne sont pas «~thread-safe~»~:

    \begin {itemize}
	\item \code {\small rand} \implique \code {\small rand\_r}
	\item \code {\small getlogin} \implique \code {\small getlogin\_r}
	\item \code {\small ttyname} \implique \code {\small ttyname\_r}
	\item \code {\small ctime} \implique \code {\small ctime\_r}
	\item etc.
    \end {itemize}

    \vspace* {3mm}

    Le manuel est votre ami : le manuel d'une fonction \texttt {x}
    mentionne également la fonction \texttt {x\_r} si elle existe

\end {frame}


\begin {frame} {Attributs de threads}
    Les threads peuvent avoir des attributs \\
    \implique positionnés lors de la création du thread

    \begin {itemize}
	\item \code {int pthread\_attr\_init (pthread\_attr\_t *attr)}
	\item \code {int pthread\_attr\_destroy (pthread\_attr\_t *attr)}
    \end {itemize}

    \vspace* {3mm}

    Le type \code {pthread\_attr\_t}~:
    \begin {itemize}
	\item est opaque
	\item peut référencer plusieurs attributs
	\item est ensuite passé à \code {pthread\_create}
    \end {itemize}
\end {frame}

\begin {frame} [fragile] {Attributs de threads}

Exemple~:

\begin {lstlisting}
pthread_attr_t pa ;

if (pthread_attr_init (&pa) != 0)
    erreur ("pthread_attr_init") ;

if (pthread_attr_setstacksize (&pa, 2 * PAGE_SIZE) != 0)
    erreur ("pthread_attr_setstacksize") ;

if (pthread_create (..., &pa, ....) != 0)
    erreur ("pthread_create") ;

pthread_attr_destroy (&pa) ;
\end{lstlisting}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Threads et signaux
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titreB {Threads et signaux}

\begin {frame} {Threads et signaux}

    Les threads d'un processus partagent~:
    \begin {itemize}
	\item l'action associée à chaque signal \\
	    \code {int sigaction (int signum, const struct sigaction *new,
	                         struct sigaction *old)}
    \end {itemize}

    Chaque thread a en propre~:
    \begin {itemize}
	\item son masque de signaux (hérité du masque du processus)


	    \code {int pthread\_sigmask (int comment, const sigset\_t *new, sigset\_t *old)}

	\item les signaux en attente de réception

    \end {itemize}
\end {frame}

\begin {frame} {Threads et signaux}

    Un signal peut être envoyé à un thread en particulier~:

    \begin {itemize}
	\item à un thread désigné \\
	    \code {int pthread\_kill (pthread\_t id, int sig)}
	\item au thread fautif \\
	    Exemple : SIGSEGV en cas de problème de pointeur
    \end {itemize}

    \vspace* {3mm}

    Si un signal n'est pas dirigé vers un thread (\code {kill()}
    ou événement externe comme SIGINT), il est envoyé à un thread
    arbitraire~:

    \begin {itemize}
	\item à l'un des threads qui attendent le signal \\
	    \code {int sigwait (const sigset\_t *set, int *sig)}
	\item à l'un des threads qui autorisent le signal
    \end {itemize}

\end {frame}

\begin {frame} {Threads et signaux}
    \begin {center}
	\includegraphics [width=.9\linewidth] {\inc/thr-sig}
    \end {center}

\end {frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Barrières
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\titreB {Barrières}

\begin {frame} {Barrières}
    Les threads peuvent utiliser de nombreux mécanismes de
    synchronisation~:
    \begin {itemize}
	\item verrous
	\item variables de condition
	\item barrières
	\item etc.
    \end {itemize}

    Commençons par un mécanisme simple~: la barrière

\end {frame}

\begin {frame} {Barrières}
    Principe~:

    \begin {itemize}
	\item une barrière de $n$ threads est bloquante pour les $n-1$
	    premiers threads

	\item lorsque le $n$-ème thread se présente à la barrière,
	    les $n$ threads sont libérés

	\item la barrière est alors de nouveau prête à fonctionner

    \end {itemize}
\end {frame}

\begin {frame} {Barrières}

    \begin {center}
	\includegraphics [width=.6\linewidth] {\inc/bar-intro}
    \end {center}

    Valeur de retour de \code {pthread\_barrier\_wait}~:
    \begin {itemize}
	\item \code {PTHREAD\_BARRIER\_SERIAL\_THREAD} pour l'un des $n$
	    threads
	\item \code {0} pour les $n-1$ autres threads.
    \end {itemize}

\end {frame}

\begin {frame} {Barrières -- Attributs}

    Les mécanismes de synchronisation peuvent aussi avoir des
    attributs~:

    \begin {itemize}
	\item \code {\small int pthread\_barrierattr\_init
	    (pthread\_barrierattr\_t *attr)}

	\item \code {\small int pthread\_barrierattr\_destroy
		    (pthread\_barrierattr\_t *attr)}

    \end {itemize}

    Exemple~: barrière partagée entre plusieurs processus ou restreinte
    aux threads du processus courant

    \begin {itemize}
	\item 
		\code {pthread\_barrierattr\_setpshared ()} \\
		\code {pthread\_barrierattr\_getpshared ()}

	\item valeur \code {PTHREAD\_PROCESS\_SHARED} ou
	    \code {PTHREAD\_PROCESS\_PRIVATE}

    \end {itemize}

    Si la barrière est partagée entre processus, il faut qu'elle soit
    en mémoire partagée.

\end {frame}

\begin {frame} [fragile] {Barrières -- Attributs}

Exemple~:

\small
\begin {lstlisting}
pthread_barrier b ;
pthread_barrierattr_t ba ;

if (pthread_barrierattr_init (&ba) != 0)
    erreur ("pthread_barrierattr_init") ;

if (pthread_barrierattr_setpshared (&ba,
                           PTHREAD_PROCESS_SHARED) != 0)
    erreur ("pthread_barrierattr_setpshared") ;

if (pthread_barrier_init (&b, &ba, 4) != 0)
    erreur ("pthread_barrier_init") ;

pthread_barrierattr_destroy (&ba) ;
\end{lstlisting}

\end{frame}
